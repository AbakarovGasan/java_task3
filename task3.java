import java.util.*;

public class task3{
//1. Квадратное уравнение ax2 + bx + c = 0 имеет либо 0, либо 1, либо 2 различных
//решения для действительных значений x. учитывая a, b и c, вы должны вернуть
//число решений в уравнение. 
    public static int solutions(int a, int b, int c){
        int d = b*b-4*a*c; //ищет дискриминант уравнения
        if (d>0) return 2 ; //если дискриминант больше нуля, уравнение имеет два решения
        if (d==0) return 1 ; //если дискриминант равен нулю, уравнение имеет одно решение
        return 0 ; //если дискриминант меньше нуля, уравнение не имеет решении
    }

//2. Напишите функцию, которая возвращает позицию второго вхождения " zip " в
//строку, или -1, если оно не происходит по крайней мере дважды. Ваш код должен
//быть достаточно общим, чтобы передать все возможные случаи, когда "zip" может
//произойти в строке. 
    public static int findZip(String a){
        //функция ищет второе вхождение zip в строку a
        //если нет второго вхождения, возвращает -1
        return a.indexOf("zip", a.indexOf("zip")+3);
    }

//3. Создайте функцию, которая проверяет, является ли целое число совершенным
//числом или нет. Совершенное число - это число, которое можно записать как
//сумму его множителей, исключая само число.
//Например, 6-это идеальное число, так как 1 + 2 + 3 = 6, где 1, 2 и 3-Все коэффициенты 6.
//Точно так же 28-это совершенное число, так как 1 + 2 + 4 + 7 + 14 = 28.
    public static boolean checkPerfect(int a){
        //проверяет, является ли число a идеальным
        int k = 0;
        for (int i = 1; i<a; i+=1){
            if (a%i==0) k+=i; //если i является делителем числа а, то прибавляем к k
        }
        return (k==a); // возвращает true если число идеальное (сумма делителей равно числу)
    }
    
//4. Создайте функцию, которая принимает строку и возвращает новую строку с
//заменой ее первого и последнего символов, за исключением трех условий:
//– Если длина строки меньше двух, верните "несовместимо".".
//– Если первый и последний символы совпадают, верните "два-это пара.". 
    public static String flipEndChars(String a){
        if (a.length()<3) return "Incompatible."; //– Если длина строки меньше двух, верните "несовместимо".".
        if (a.charAt(0)==a.charAt(a.length()-1)) return "Two's a pair."; //– Если первый и последний символы совпадают, верните "два-это пара.".
        return a.charAt(a.length()-1)+a.substring(1, a.length()-1)+a.charAt(0);
    }
    
    
//5. Создайте функцию, которая определяет, является ли строка допустимым
//шестнадцатеричным кодом.
//Шестнадцатеричный код должен начинаться с фунтового ключа # и иметь длину ровно 6
//символов. Каждый символ должен быть цифрой от 0-9 или буквенным символом от A-F.
//все буквенные символы могут быть прописными или строчными. 
    public static boolean isValidHexCode( String j ){
        if (j.charAt(0)!='#') return false; 
        
        try{//проверить, является ли часть строки без # hex - кодом
           Integer.parseInt(j.substring(1), 16);
        }
        catch(java.lang.NumberFormatException e){
            return false; //если нет, вернуть false
        }
        return true;
    }
    
 
// 6. Напишите функцию, которая возвращает true, если два массива имеют одинаковое
//количество уникальных элементов, и false в противном случае.
    public static boolean same(int []a, int []b){
        //функция возвращает true если количество уникальных чисел в массивах равны
        return countDistinct(a)==countDistinct(b);
    }
    
    public static int countDistinct(int arr[]) 
    { //функция возвращает количество уникальных чисел в массиве
    int n = arr.length;
    int res = 0; 
    int i;
    for (i = 0; i < n; i+=1)  
    { 
        int j = 0; 
        for (j = 0; j < i; j++) {
            if (arr[i] == arr[j]) break; 
        };
        if (i == j) res++; 
    } 
    return res; 
    } 
    
// 7. Число Капрекара-это положительное целое число, которое после возведения в
//квадрат и разбиения на две лексикографические части равно сумме двух
//полученных новых чисел:
//– Если количество цифр квадратного числа четное, то левая и правая части будут иметь
//одинаковую длину.
//– Если количество цифр квадратного числа нечетно, то правая часть будет самой длинной
//половиной, а левая-самой маленькой или равной нулю, если количество цифр равно 1.
//– Учитывая положительное целое число n, реализуйте функцию, которая возвращает true,
//если это число Капрекара, и false, если это не так. 
    
    public static boolean isKaprekar(int a){
        String out = String.valueOf((int)Math.pow(a, 2)); // получить строку
        // от числа а, возведенной в квадрат
        int len = out.length(); // размер строки
        if (len==1) return false; //ecли размер строки равен 1, то квадрат числа больше а
        len = len / 2; // если число нечетное, то остаток отбрасывается
        String left = out.substring(0, len); // правая часть числа
        String right = out.substring(len); // левая часть числа
        return ( Integer.parseInt(left)+Integer.parseInt(right) ) == a;//возвращает 
        //true, если число является числом Капрекара 
    }
    
// 8. Напишите функцию, которая возвращает самую длинную последовательность
//последовательных нулей в двоичной строке. 
    
    public static String longestZero(String bin){
        String out = "";
        try{
            Integer.parseInt(bin, 2); //проверяет, является ли число двоичным, если нет, 
            // то вызывается ошибка
            int len = bin.length(); // размер строки
            int zeros = 0; // число последовательных нулей
            int max = 0; // максимальное число последовательных нулей
            boolean is_counting = false; // флаг, указывающий на то, ведет ли отсчет нулей
            char temp = '1'; // временная переменная
            int i = 0; // переменная для цикла
            while (i<len){
                temp = bin.charAt(i); // присвоить temp символ из строки
                i+=1; 
                if (is_counting & (temp == '1')){
                    is_counting = false; // если введется счет нулей
                    // и символ равен 1, то приостановить счет нулей
                    if (zeros > max){
                        max = zeros;
                    }
                }
                else if (is_counting & (temp == '0')){
                    zeros +=1;
                }
                else if ((!is_counting) & (temp == '0')){
                    zeros = 1;
                    is_counting = true;
                }
            }
            if (zeros > max){
                max = zeros;
            }
            for (i=0; i<max; i++){
                out+='0';
            }
            return out;
        }
        catch(Exception e){
            return out;
        }
    } 
  
//  9. Если задано целое число, создайте функцию, которая возвращает следующее
//простое число. Если число простое, верните само число. 
    static public int nextPrime(int a){
        while (!isPrime(a)){
         //    System.out.println(isPrime(a));
             a++; // увеличивать число до тех пор, пока не станет простым
        }
        return a;
    }    
    
    //проверяет, является ли число простым
    public static boolean isPrime(int a){
        int j = (int)primes.get(primes.size()-1); // берется последнее число из списка primes (список простых чисел)
        l1: while (a>j){
            // выполняется до тех пор, пока последнее число из списка primes (список простых чисел) меньше а
            j+=2;  
            for (int i = 0; i < primes.size(); i++){
                int f = (int)(primes.get(i));
                if ((j%f)==0) continue l1; 
            }
            primes.add(j); // если число не делится без остатка ни на одно из чисел из списка primes,
            // то оно добавляется в конец списка
        }
        if (a==j) return true;
        if (a<j) return primes.contains(a);
        return true;
    }
    static public List primes = new ArrayList<Integer> (Arrays.asList(2, 3, 5));
    
    public static void main(String [] argv){
        System.out.println(nextPrime(4));
    }
}

